---
title: "데이터 시각화 교과서(Fundamentals of Data Visualization)"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
categories:
  - visualization
tags:
  - R
  - visualization
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
      css: "post_style.css"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                      comment = "#>")

# https://tibble.tidyverse.org/reference/formatting.html
options(tibble.print_max = 10)
options(tibble.max_extra_cols = 5)
# options(max.print = 300)

library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
library(googledrive) # Import dataset from the google drive
library(readr) # To read csv file
library(lubridate)
library(operators)
library(magrittr)
library(ggridges) # geom_density_line()을 위한 패키지 로드
library(tinter) # darken()을 위한 패키지 로드
library(pkgsimon) # theme_dviz_hgrid()를 위함
library(showtext)
font_add_google('Noto Sans KR', 'notosanskr')
font_add_google('Noto Sans', 'notosans')
font_add_google('Nanum Gothic', 'nanumgothic')
library(ggforce) # sina plot을 위한 패키지 
# library(dviz.supp) # colorblindr가 4.0.2에서 사용 불가해서 설치가 안됨 
```


```{r, echo=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "19_temp")

for(i in 1:8){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

## ch 2
여러 지역의 월 별 온도 대비를 tile로 보여준다는 것이 심미적으로도 차이를 드러내는 것에도 큰 장점으로 보인다. 우리나라 주요도시의 19년 월 별 온도 데이터를 이용해 같은 방식으로 해보자.  

```{r 19년도 대한민국 주요 도시의 월 별 평균 온도, fig.cap="19년도 대한민국 주요 도시의 월 별 평균 온도", fig.height=6}
# 데이터셋 로드 
seoul <- read_csv("seoul_19_temp.csv", col_names = FALSE, skip = 1)
busan <- read_csv("busan_19_temp.csv", col_names = FALSE, skip = 1)
deajeon <- read_csv("deajeon_19_temp.csv", col_names = FALSE, skip = 1)
incheon <- read_csv("incheon_19_temp.csv", col_names = FALSE, skip = 1)
gwangju <- read_csv("gwangju_19_temp.csv", col_names = FALSE, skip = 1)
ulsan <- read_csv("ulsan_19_temp.csv", col_names = FALSE, skip = 1)
deagu <- read_csv("deagu_19_temp.csv", col_names = FALSE, skip = 1)
jeju <- read_csv("jeju_19_temp.csv", col_names = FALSE, skip = 1)

# bind 후 간단한 편집
rbind(seoul, busan, deajeon, incheon, gwangju, ulsan, deagu, jeju) %>% 
  as.tibble() %>% 
  mutate(index = rep(c("Seoul", "Busan", "Deajeon", "Incheon", "Gwangju", "Ulsan", "Deagu", "Jeju"), each = 12)) %>% 
  dplyr::rename(Month = X1, location = X2, max = X3, min = X4, mean = X5) %>% 
  select(index, everything()) %>% 
  mutate(Month = 
           factor(
             str_remove(Month, "-19"), 
             levels = c("Jan","Feb","Mar","Apr","May","Jun", "Jul","Aug","Sep","Oct","Nov","Dec")
             )
         ) %>% 
  
  ## ggplot 시작 ## 
  ggplot(aes(x = Month, y = index, fill = mean)) + 
  
  # geom_tile 이용
  geom_tile(width = .95, height = 0.95) + 
  scale_fill_viridis_c(option = "B", begin = 0.15, end = 0.98,
                       name = "Celsisu (°C)") + 
  scale_y_discrete(name = NULL) +
  coord_fixed(expand = FALSE) +
  theme(axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.text.y = element_text(size = 12),
        legend.title = element_text(size = 12)
        )


```



## ch 5

To draw list 

- Mosaic plot, Tree map, Parallel sets : 여러 그룹 변수에 따라 비율이 정해지는 경우 사용

- 2차원 상자, 육각형 상자 : 데이퍼 값이 많은 데이터셋을 그릴 때 유용

- 지리 데이터를 이용한 시각화

- 눈 모양(eyes) 도표, 감은 눈 모양(half-eyes) 도표 

## ch 6. 수량 데이터의 시각화
### 점 도표와 히트맵 : 히트맵
- `점 도표와 히트맵`을 선택한 이유 : `막대도표의 다양한 활용`나 `묶은 막대와 누적 막대`에서 다루는 내용이 **익숙한 그래프의 올바른 활용**이라면 `점 도표와 히트맵`은 상대적으로 익숙하지 않은 히트맵의 사용에 대해 다루기 있기 때문

```{r, echo=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "us-counties")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
us_counties <- read_csv("us-counties.csv")
```

```{r, fig.cap="미국의 5백만명당 코로나 확진자 추세", fig.height=6}
us_counties %>% 
  # 50개주만 따로 선택
  dplyr::filter(!(state %in% c("District of Columbia",
                        "Guam",
                        "Northern Mariana Islands",
                        "Puerto Rico",
                        "Virgin Islands"))) %>% 
  # 1월 후반부터 측정되었으므로 1월 자료는 제외
  dplyr::filter(
    lubridate::month(date) > 
      lubridate::month("2020-01-21")
  ) %>% 
  # 월마다 index 추가
  mutate(month_index = 
           case_when(
             lubridate::month(date) == 2 ~ "Feb", 
             lubridate::month(date) == 3 ~ "Mar",
             lubridate::month(date) == 4 ~ "Apr", 
             lubridate::month(date) == 5 ~ "May",
             lubridate::month(date) == 6 ~ "Jun",
             lubridate::month(date) == 7 ~ "Jul",
             lubridate::month(date) == 8 ~ "Aug"
           )
  ) %>% 
  
  # 추가된 index를 factor로 변환 : 정렬을 위함
  mutate(month_index = factor(month_index, levels = c("Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug"))) %>% 
  
  # 주마다 월별 확진자 수 합산을 위한 grouping 
  group_by(state, month_index) %>% 
  # dplyr::summarise로 사용하지 않으면 knit 중 에러 발생
  # Q. masking이 된 것도 아닌데 왜지? 
  dplyr::summarise(sum_cases = sum(cases)) %>% 
  # 월 별 총 확진자 수를 위한 group_by
  ungroup() %>% group_by(month_index) %>% 
  # 주, 월 별 5백만명 당 확진자 비율 생성
  mutate(month_case_rate = sum_cases/5000000) %>% 
  
  # state 정렬을 위한 group_by
  ungroup() %>% group_by(state) %>% 
  arrange(desc(month_case_rate)) %>% ungroup() %>% 
  mutate(state = fct_rev(factor(state, levels = unique(state)))) %>% 
  
  # 5백만명 이상 확진자가 있는 경우를 처리하기 위한 값 변환. 
  mutate(month_case_rate = ifelse(month_case_rate > 1, 1, month_case_rate)) %>%
  ungroup() %>% 
  # ggplot part 
  ggplot(aes(x = month_index, y = state, fill = month_case_rate)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.0002, end = 1,
    name = "incidence per 5 million",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) + 
  # scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  labs(x = "Month") + 
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5
  ) 
```

```{r 미국의-주별-한달-주기-5백만명당-코로나-확진자-추세, fig.cap='미국의 주별, 한달 주기 5백만명당 코로나 확진자 추세', fig.height=6}
# 이전 plot은 1월 데이터를 모두 제거하고 2월 데이터로만 진행했다. 
# 초기 확진자 등장 또한 중요한 정보이므로 삭제하지 않는 것이 더 좋지 않을까? 
# date는 20년 1월 21일부터 20년 8월 18일까지 존재하므로 30일주기로 간격을 설정한 후 그래프를 다시 그려보자. 

# 날짜 index를 위한 지역 설정 : 미국
Sys.setlocale("LC_TIME", "English_United States.1252")

us_counties %>% 
  # 50개주만 따로 선택
  filter(!(state %in% c("District of Columbia",
                        "Guam",
                        "Northern Mariana Islands",
                        "Puerto Rico",
                        "Virgin Islands"))) %>% 
  # 기간 index를 추가
  # Q. 이 반복을 처리할 방법이 있을탠데
  mutate(term_index = 
           case_when(
             date[1] + 30 >= date ~ paste0(format(date[1], "%b %d"), "~", format(date[1] + 30, "%b %d")) ,
             date[1] + 60 >= date ~ paste0(format(date[1] + 31, "%b %d"), "~", format(date[1] + 60, "%b %d")), 
             date[1] + 90 >= date ~ paste0(format(date[1] + 61, "%b %d"), "~", format(date[1] + 90, "%b %d")), 
             date[1] + 120 >= date ~ paste0(format(date[1] + 91, "%b %d"), "~", format(date[1] + 120, "%b %d")), 
             date[1] + 150 >= date ~ paste0(format(date[1] + 121, "%b %d"), "~", format(date[1] + 150, "%b %d")), 
             date[1] + 180 >= date ~ paste0(format(date[1] + 151, "%b %d"), "~", format(date[1] + 180, "%b %d")), 
             date[1] + 210 >= date ~ paste0(format(date[1] + 181, "%b %d"), "~", format(date[1] + 210, "%b %d")) 
           )  
  ) %>%
  # 추가된 index를 factor로 변환 : 정렬을 위함
  mutate(term_index = factor(term_index, 
                             levels = c("Jan 21~Feb 20",
                                        "Feb 21~Mar 21",
                                        "Mar 22~Apr 20",
                                        "Apr 21~May 20",
                                        "May 21~Jun 19",
                                        "Jun 20~Jul 19",
                                        "Jul 20~Aug 18"))
  ) %>% 
  
  # 주마다 월별 확진자 수 합산을 위한 grouping 
  group_by(state, term_index) %>% 
  # 주, 월 별 확진자 수 생성
  
  # dplyr::summarise로 사용하지 않으면 knit 중 에러 발생
  # Q. masking이 된 것도 아닌데 왜지? 
  dplyr::summarise(sum_cases = sum(cases)) %>% 
  # 월 별 총 확진자 수를 위한 group_by
  ungroup() %>% group_by(term_index) %>% 
  # 주, 월 별 5백만명 당 확진자 비율 생성
  mutate(term_case_rate = sum_cases/5000000) %>% 
  
  # state 정렬을 위한 group_by
  ungroup() %>% group_by(state) %>% 
  arrange(desc(term_case_rate)) %>% ungroup() %>% 
  mutate(state = fct_rev(factor(state, levels = unique(state)))) %>% 
  
  # 5백만명 이상 확진자가 있는 경우를 처리하기 위한 값 변환. 
  mutate(term_case_rate = ifelse(term_case_rate > 1, 1, term_case_rate)) %>%
  ungroup() %>% 
  
  # ggplot part 
  ggplot(aes(x = term_index, y = state, fill = term_case_rate)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.0002, end = 1,
    name = "incidence per 5 million",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) + 
  # scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  labs(x = "Term") + 
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5
  )

Sys.setlocale("LC_TIME", "Korean_Korea.949")
```


```{r, include=FALSE}
library(vcdExtra)
vcdExtra::datasets(c("plyr", "dplyr", "vcdExtra", "tidyr", "sinaplot"))
```


## ch 7. 데이터 분포의 시각화 : 히스토그램(histogram)과 밀도 도표(density plot)

- 사실, 히스토그램을 사용하는 것이 부적절한 경우가 많다. bin 개수마다 모양이 달라져서 최적의 bin을 알아내는 것도 번거로운 일이다. 만약 분포를 표현해야하는 변수가 여러 개라면 히스토그램은 더욱 사용하기 어려워진다. 

- 필자도, 나도 density plot을 추천하는 이유는 히스토그램보다 더 깔끔하게 충분한 정보를 전달할 수 있기 때문이다. 

- 이번 파트의 핵심은 `facet_`을 이용해 분할하는 것을 넘어서 전체 그룹에 대한 분포까지 보여주는 density plot을 그리는 것이라 생각한다. 코드를 참조해서 수정해보았다. 


```{r 타이타닉-탑승자의-생존여부에-따른-나이-분포-그래프, fig.cap="타이타닉 탑승자의 생존여부에 따른 나이 분포 그래프"}
# geom_density_line()을 위한 패키지 로드
library(ggridges)
# darken()을 위한 패키지 로드
library(tinter)


# legend의 order를 "생존", "사망"으로 만들기 위함
# https://stackoverflow.com/questions/50420205/how-to-reorder-overlaying-order-of-geoms-but-keep-legend-order-intact-in-ggplot
Titanicp$survived2 <- factor(Titanicp$survived, levels = c("survived", "died"), labels = c("생존", "사망"))

Titanicp %>% 
  mutate(survived = factor(survived, levels = c("survived", "died"), labels = c("생존", "사망"))) %>% 
  mutate(survived = fct_rev(survived)) %>% # density 범위의 overlap 때문에 조정
  
  # ggplot part
  ggplot(aes(x = age, y = stat(count), 
             color = fct_rev(survived2), 
             fill = fct_rev(survived2))) + 
  geom_density_line(bw = 2, alpha = 0.5) + 
  # x축 조정
  scale_x_continuous(name = "나이(세)",  # 이름
                     limits = c(0, 85), # x축의 최소, 최대 범위
                     expand = c(0, 0)) + # 원점에서의 시작, x축 끝의 여백을 최소화하기 위한 expand
  
  scale_y_continuous(name = "등장 횟수", # 이름 
                     limits = c(0, 27), # y축의 최소, 최대 범위 
                     expand = c(0, 0)) + # 원점에서의 시작, y축 끝의 여백을 최소화하기 위한 expand
  
  # plot의 색깔 조정
  scale_fill_manual(name = "생존여부", # 범례 이름
                    values = c("#3399FF", "#FF9933"), # 채움 색깔 설정
                    breaks = levels(Titanicp$survived2)) + # 범례 순서를 위한 breaks
  
  scale_color_manual(name = "생존여부", # 범례이름
                     values = darken(c("#3399FF", "#FF9933"), 0.5), # 라인 색깔 설정
                     breaks = levels(Titanicp$survived2)) + # 범례 순서를 위한 breaks
  
  
  theme_dviz_hgrid() + # background 설정
  # guides(fill = guide_legend(override.aes = list(linetype = 0))) + # 차이를 모르겠는데1
  # coord_cartesian(clip = "on") + # 차이를 모르겠는데2
  theme(
    axis.line.x = element_blank(),
    legend.position = c(.9, .7),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(10, 10, 10, 10) # 상, 우, 하, 좌
  )
```


```{r 타이타닉-탑승자의-생존여부에-따른-나이-분포-분할-그래프, fig.cap="타이타닉 탑승자의 생존여부에 따른 나이 분포 분할 그래프"}
# showtext_auto()

Titanicp %>% 
  tidyr::drop_na(age) %>% 
  mutate(survived = factor(survived, levels = c("survived", "died"), labels = c("생존", "사망"))) %>% 
  
# ggplot part
  ggplot(aes(x = age, y = stat(count))) + 
  
  geom_density_line(
    data = select(Titanicp, -survived), aes(fill = "전체 탑승객"),
    color = "transparent"
  ) + 
  geom_density_line(aes(fill = survived), bw = 2, color = "transparent") +
  
  # x축 조정
  scale_x_continuous(name = "탑승객의 나이(세)",  # 이름
                     limits = c(0, 85), # x축의 최소, 최대 범위
                     expand = c(0, 0)) + # 원점에서의 시작, x축 끝의 여백을 최소화하기 위한 expand
  
  scale_y_continuous(name = "등장 횟수", # 이름 
                     limits = c(0, 45), # y축의 최소, 최대 범위 
                     expand = c(0, 0)) + # 원점에서의 시작, y축 끝의 여백을 최소화하기 위한 expand

  scale_fill_manual(
    values = c("#A0A0A0", "#3399FF", "#FF9933"), 
    breaks = c("전체 탑승객", "생존", "사망"),
    labels = c("전체 탑승객", "생존  ", "사망"),
    name = NULL,
    guide = guide_legend(direction = "horizontal")
  ) +
  
  coord_cartesian(clip = "off") +
  
  facet_wrap(~survived) +
  
  theme_dviz_hgrid() +
  
  theme(
    axis.line.x = element_blank(),
    strip.text = element_text(margin = margin(0, 0, 0.2, 0, "cm"),
                              family = "notosanskr",
                              size = 14),
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm"), 
    # facet_wrap으로 생기는 박스 색깔 조정
    # https://stackoverflow.com/questions/19440069/ggplot2-facet-wrap-strip-color-based-on-variable-in-data-set
    strip.background = element_rect(fill="white"),
    
    # # ggplot 내에서 글꼴 변경
    # https://blog.itpaper.co.kr/rdata-graph1-%EC%A0%9C%EB%AA%A9,%EC%B6%95%EC%84%A4%EC%A0%95/
    # https://danbi-ncsoft.github.io/etc/2018/07/24/use-your-font-in-r.html
    # https://statisticsglobe.com/change-font-size-of-ggplot2-plot-in-r-axis-text-main-title-legend
    # text = element_text(family = "notosanskr") # 한번에 변경하기
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16),
    legend.text = element_text(family = "notosanskr", size = 12)
  )
```

## ch 9. 여러 분포 상태의 결합 시각화

### 가로축에 기준을 둔 분포 상태의 시각화 : Sinaplot
jitter + violin ploting을 이용한 방법으로, 관측치가 충분하지 않은 상황에서 사용하기 껄끄럽다는 violin plot의 단점을 개선한 방법이다. 
```{r}
library(ggforce) # geom_sina를 지원한다. 
library(sinaplot) # dataset, blood를 위한 로드

blood %>% 
  
  ggplot(aes(x = Class, y = Gene)) +
  geom_violin(color = "transparent", fill = "#A0A0A0") + 
  geom_sina(size = 1) + 

  theme(plot.margin = margin(3, 7, 3, 1.5), 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.title.x = element_text(family = "notosanskr", size = 16),
        axis.title.y = element_text(family = "notosanskr", size = 16))
```


### 세로축에 기준을 둔 분포 상태의 시각화 : ridgeline plot 

```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "70_20")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

```{r ridgeline-plot-실습, fig.cap="70년부터 19년까지 한국 전체 월별 평균 기온과 서울과 부산의 월별 평균기온의 차이에 대한 분포"}
# 70년부텨 20년 7월까지, 서울과 광역시, 제주시의 월별 평균 기온 데이터 불러오기
# https://data.kma.go.kr/cmmn/main.do 참고 
# http://drtagkim.blogspot.com/2019/02/r-csv.html : 한글 꺠져서 나오는 문제 
ROK_70_20 <- read_csv("한국_주요시_평균기온_70_20까지.csv", locale=locale('ko',encoding='euc-kr'))

ROK_70_20 %>% 
  select(-`지점`) %>% 
  mutate(`일시` = parse_date(`일시`, format = "%Y-%m")) %>% 
  mutate(`연도` = year(`일시`)) %>% 
  filter(`연도` < 2020) %>% 
  
  dplyr::group_by(`일시`) %>% 
  dplyr::mutate(`월 별 전체 평균` = mean(`평균기온(°C)`)) %>% 
  ungroup() %>% 
  
  mutate(`기온 차이(°C)` = `평균기온(°C)` - `월 별 전체 평균`) %>% 
  filter(`지점명` == "서울" | `지점명` == "부산") %>% 
  
  
  ggplot(aes(x = `기온 차이(°C)`, y = `연도`, 
             group = interaction(`지점명`, factor(`연도`)),
             fill = interaction(`지점명`, factor(`연도`))
             )) + 
  geom_density_ridges(scale = 5, size = 0.25, rel_min_height = 0.01, alpha=0.9, color = "white") + 
  scale_x_continuous(
    name = "지역 평균 기온 - 전체 평균 기온",
    limits = c(-6, 6),
    breaks = seq(-6, 6, 1)
  ) +
  scale_y_reverse(
    name = "연도",
    expand = c(0, 0), breaks=c(seq(2019, 1970, -10))
  ) +
  scale_fill_cyclical(
    breaks = c("서울.1970", "부산.1970"),
    labels = c(`서울.1970` = "서울특별시", `부산.1970` = "부산광역시"),
    values = c("#ff8000", "#0080ff", "#ff9933", "#3399ff"),
    name = NULL,
    guide = "legend"
  ) + 
  theme_dviz_grid() +
  theme(
    axis.text.y = element_text(vjust = 0),
    legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.direction = "horizontal",
    legend.background = element_rect(fill = "white"),
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16)
  )
  
```
