---
title: "데이터 시각화 교과서(Fundamentals of Data Visualization)"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
categories:
  - visualization
tags:
  - R
  - visualization
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
      css: "post_style.css"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                      comment = "#>")

# https://tibble.tidyverse.org/reference/formatting.html
options(tibble.print_max = 10)
options(tibble.max_extra_cols = 5)
# options(max.print = 300)

library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
library(googledrive) # Import dataset from the google drive
library(readr) # To read csv file
library(lubridate)
library(operators)
library(magrittr)
library(ggridges) # geom_density_line()을 위한 패키지 로드
library(tinter) # darken()을 위한 패키지 로드
library(pkgsimon) # theme_dviz_hgrid()를 위함
library(showtext)
font_add_google('Noto Sans KR', 'notosanskr')
font_add_google('Noto Sans', 'notosans')
font_add_google('Nanum Gothic', 'nanumgothic')
library(ggforce) # sina plot을 위한 패키지 
# library(dviz.supp) # colorblindr가 4.0.2에서 사용 불가해서 설치가 안됨 
library(foreign)
library(treemapify) # geom_treemap
```


```{r, echo=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "19_temp")

for(i in 1:8){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

## ch 2
여러 지역의 월 별 온도 대비를 tile로 보여준다는 것이 심미적으로도 차이를 드러내는 것에도 큰 장점으로 보인다. 우리나라 주요도시의 19년 월 별 온도 데이터를 이용해 같은 방식으로 해보자.  

```{r 19년도 대한민국 주요 도시의 월 별 평균 온도, fig.cap="19년도 대한민국 주요 도시의 월 별 평균 온도", fig.height=6}
# 데이터셋 로드 
seoul <- read_csv("seoul_19_temp.csv", col_names = FALSE, skip = 1)
busan <- read_csv("busan_19_temp.csv", col_names = FALSE, skip = 1)
deajeon <- read_csv("deajeon_19_temp.csv", col_names = FALSE, skip = 1)
incheon <- read_csv("incheon_19_temp.csv", col_names = FALSE, skip = 1)
gwangju <- read_csv("gwangju_19_temp.csv", col_names = FALSE, skip = 1)
ulsan <- read_csv("ulsan_19_temp.csv", col_names = FALSE, skip = 1)
deagu <- read_csv("deagu_19_temp.csv", col_names = FALSE, skip = 1)
jeju <- read_csv("jeju_19_temp.csv", col_names = FALSE, skip = 1)

# bind 후 간단한 편집
rbind(seoul, busan, deajeon, incheon, gwangju, ulsan, deagu, jeju) %>% 
  as.tibble() %>% 
  mutate(index = rep(c("Seoul", "Busan", "Deajeon", "Incheon", "Gwangju", "Ulsan", "Deagu", "Jeju"), each = 12)) %>% 
  dplyr::rename(Month = X1, location = X2, max = X3, min = X4, mean = X5) %>% 
  select(index, everything()) %>% 
  mutate(Month = 
           factor(
             str_remove(Month, "-19"), 
             levels = c("Jan","Feb","Mar","Apr","May","Jun", "Jul","Aug","Sep","Oct","Nov","Dec")
             )
         ) %>% 
  
  ## ggplot 시작 ## 
  ggplot(aes(x = Month, y = index, fill = mean)) + 
  
  # geom_tile 이용
  geom_tile(width = .95, height = 0.95) + 
  scale_fill_viridis_c(option = "B", begin = 0.15, end = 0.98,
                       name = "Celsisu (°C)") + 
  scale_y_discrete(name = NULL) +
  coord_fixed(expand = FALSE) +
  theme(axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.text.y = element_text(size = 12),
        legend.title = element_text(size = 12)
        )

```



## ch 5

To draw list 

- Mosaic plot, Tree map, Parallel sets : 여러 그룹 변수에 따라 비율이 정해지는 경우 사용

- 2차원 상자, 육각형 상자 : 데이퍼 값이 많은 데이터셋을 그릴 때 유용

- 지리 데이터를 이용한 시각화

- 눈 모양(eyes) 도표, 감은 눈 모양(half-eyes) 도표 

## ch 6. 수량 데이터의 시각화
### 점 도표와 히트맵 : 히트맵
- `점 도표와 히트맵`을 선택한 이유 : `막대도표의 다양한 활용`나 `묶은 막대와 누적 막대`에서 다루는 내용이 **익숙한 그래프의 올바른 활용**이라면 `점 도표와 히트맵`은 상대적으로 익숙하지 않은 히트맵의 사용에 대해 다루기 있기 때문

```{r, echo=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "us-counties")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
us_counties <- read_csv("us-counties.csv")
```

```{r, fig.cap="미국의 5백만명당 코로나 확진자 추세", fig.height=6}
us_counties %>% 
  # 50개주만 따로 선택
  dplyr::filter(!(state %in% c("District of Columbia",
                        "Guam",
                        "Northern Mariana Islands",
                        "Puerto Rico",
                        "Virgin Islands"))) %>% 
  # 1월 후반부터 측정되었으므로 1월 자료는 제외
  dplyr::filter(
    lubridate::month(date) > 
      lubridate::month("2020-01-21")
  ) %>% 
  # 월마다 index 추가
  mutate(month_index = 
           case_when(
             lubridate::month(date) == 2 ~ "Feb", 
             lubridate::month(date) == 3 ~ "Mar",
             lubridate::month(date) == 4 ~ "Apr", 
             lubridate::month(date) == 5 ~ "May",
             lubridate::month(date) == 6 ~ "Jun",
             lubridate::month(date) == 7 ~ "Jul",
             lubridate::month(date) == 8 ~ "Aug"
           )
  ) %>% 
  
  # 추가된 index를 factor로 변환 : 정렬을 위함
  mutate(month_index = factor(month_index, levels = c("Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug"))) %>% 
  
  # 주마다 월별 확진자 수 합산을 위한 grouping 
  group_by(state, month_index) %>% 
  # dplyr::summarise로 사용하지 않으면 knit 중 에러 발생
  # Q. masking이 된 것도 아닌데 왜지? 
  dplyr::summarise(sum_cases = sum(cases)) %>% 
  # 월 별 총 확진자 수를 위한 group_by
  ungroup() %>% group_by(month_index) %>% 
  # 주, 월 별 5백만명 당 확진자 비율 생성
  mutate(month_case_rate = sum_cases/5000000) %>% 
  
  # state 정렬을 위한 group_by
  ungroup() %>% group_by(state) %>% 
  arrange(desc(month_case_rate)) %>% ungroup() %>% 
  mutate(state = fct_rev(factor(state, levels = unique(state)))) %>% 
  
  # 5백만명 이상 확진자가 있는 경우를 처리하기 위한 값 변환. 
  mutate(month_case_rate = ifelse(month_case_rate > 1, 1, month_case_rate)) %>%
  ungroup() %>% 
  # ggplot part 
  ggplot(aes(x = month_index, y = state, fill = month_case_rate)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.0002, end = 1,
    name = "incidence per 5 million",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) + 
  # scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  labs(x = "Month") + 
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5
  ) 
```

```{r 미국의-주별-한달-주기-5백만명당-코로나-확진자-추세, fig.cap='미국의 주별, 한달 주기 5백만명당 코로나 확진자 추세', fig.height=6}
# 이전 plot은 1월 데이터를 모두 제거하고 2월 데이터로만 진행했다. 
# 초기 확진자 등장 또한 중요한 정보이므로 삭제하지 않는 것이 더 좋지 않을까? 
# date는 20년 1월 21일부터 20년 8월 18일까지 존재하므로 30일주기로 간격을 설정한 후 그래프를 다시 그려보자. 

# 날짜 index를 위한 지역 설정 : 미국
Sys.setlocale("LC_TIME", "English_United States.1252")

us_counties %>% 
  # 50개주만 따로 선택
  filter(!(state %in% c("District of Columbia",
                        "Guam",
                        "Northern Mariana Islands",
                        "Puerto Rico",
                        "Virgin Islands"))) %>% 
  # 기간 index를 추가
  # Q. 이 반복을 처리할 방법이 있을탠데
  mutate(term_index = 
           case_when(
             date[1] + 30 >= date ~ paste0(format(date[1], "%b %d"), "~", format(date[1] + 30, "%b %d")) ,
             date[1] + 60 >= date ~ paste0(format(date[1] + 31, "%b %d"), "~", format(date[1] + 60, "%b %d")), 
             date[1] + 90 >= date ~ paste0(format(date[1] + 61, "%b %d"), "~", format(date[1] + 90, "%b %d")), 
             date[1] + 120 >= date ~ paste0(format(date[1] + 91, "%b %d"), "~", format(date[1] + 120, "%b %d")), 
             date[1] + 150 >= date ~ paste0(format(date[1] + 121, "%b %d"), "~", format(date[1] + 150, "%b %d")), 
             date[1] + 180 >= date ~ paste0(format(date[1] + 151, "%b %d"), "~", format(date[1] + 180, "%b %d")), 
             date[1] + 210 >= date ~ paste0(format(date[1] + 181, "%b %d"), "~", format(date[1] + 210, "%b %d")) 
           )  
  ) %>%
  # 추가된 index를 factor로 변환 : 정렬을 위함
  mutate(term_index = factor(term_index, 
                             levels = c("Jan 21~Feb 20",
                                        "Feb 21~Mar 21",
                                        "Mar 22~Apr 20",
                                        "Apr 21~May 20",
                                        "May 21~Jun 19",
                                        "Jun 20~Jul 19",
                                        "Jul 20~Aug 18"))
  ) %>% 
  
  # 주마다 월별 확진자 수 합산을 위한 grouping 
  group_by(state, term_index) %>% 
  # 주, 월 별 확진자 수 생성
  
  # dplyr::summarise로 사용하지 않으면 knit 중 에러 발생
  # Q. masking이 된 것도 아닌데 왜지? 
  dplyr::summarise(sum_cases = sum(cases)) %>% 
  # 월 별 총 확진자 수를 위한 group_by
  ungroup() %>% group_by(term_index) %>% 
  # 주, 월 별 5백만명 당 확진자 비율 생성
  mutate(term_case_rate = sum_cases/5000000) %>% 
  
  # state 정렬을 위한 group_by
  ungroup() %>% group_by(state) %>% 
  arrange(desc(term_case_rate)) %>% ungroup() %>% 
  mutate(state = fct_rev(factor(state, levels = unique(state)))) %>% 
  
  # 5백만명 이상 확진자가 있는 경우를 처리하기 위한 값 변환. 
  mutate(term_case_rate = ifelse(term_case_rate > 1, 1, term_case_rate)) %>%
  ungroup() %>% 
  
  # ggplot part 
  ggplot(aes(x = term_index, y = state, fill = term_case_rate)) +
  geom_tile(color = "white", size = 0.25) +
  scale_fill_viridis_c(
    option = "A", begin = 0.0002, end = 1,
    name = "incidence per 5 million",
    guide = guide_colorbar(
      direction = "horizontal",
      label.position = "bottom",
      title.position = "top",
      ticks = FALSE,
      barwidth = grid::unit(3.5, "in"),
      barheight = grid::unit(0.2, "in")
    )
  ) + 
  # scale_x_continuous(expand = c(0, 0), name = NULL) +
  scale_y_discrete(name = NULL, position = "right") +
  labs(x = "Term") + 
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.ticks.length = grid::unit(1, "pt"),
    legend.position = "top",
    legend.justification = "left",
    legend.title.align = 0.5
  )

Sys.setlocale("LC_TIME", "Korean_Korea.949")
```


```{r, include=FALSE}
library(vcdExtra)
vcdExtra::datasets(c("plyr", "dplyr", "vcdExtra", "tidyr", "sinaplot"))
```


## ch 7. 데이터 분포의 시각화 : 히스토그램(histogram)과 밀도 도표(density plot)

- 사실, 히스토그램을 사용하는 것이 부적절한 경우가 많다. bin 개수마다 모양이 달라져서 최적의 bin을 알아내는 것도 번거로운 일이다. 만약 분포를 표현해야하는 변수가 여러 개라면 히스토그램은 더욱 사용하기 어려워진다. 

- 필자도, 나도 density plot을 추천하는 이유는 히스토그램보다 더 깔끔하게 충분한 정보를 전달할 수 있기 때문이다. 

- 이번 파트의 핵심은 `facet_`을 이용해 분할하는 것을 넘어서 전체 그룹에 대한 분포까지 보여주는 density plot을 그리는 것이라 생각한다. 코드를 참조해서 수정해보았다. 


```{r 타이타닉-탑승자의-생존여부에-따른-나이-분포-그래프, fig.cap="타이타닉 탑승자의 생존여부에 따른 나이 분포 그래프"}
# geom_density_line()을 위한 패키지 로드
library(ggridges)
# darken()을 위한 패키지 로드
library(tinter)


# legend의 order를 "생존", "사망"으로 만들기 위함
# https://stackoverflow.com/questions/50420205/how-to-reorder-overlaying-order-of-geoms-but-keep-legend-order-intact-in-ggplot
Titanicp$survived2 <- factor(Titanicp$survived, levels = c("survived", "died"), labels = c("생존", "사망"))

Titanicp %>% 
  mutate(survived = factor(survived, levels = c("survived", "died"), labels = c("생존", "사망"))) %>% 
  mutate(survived = fct_rev(survived)) %>% # density 범위의 overlap 때문에 조정
  
  # ggplot part
  ggplot(aes(x = age, y = stat(count), 
             color = fct_rev(survived2), 
             fill = fct_rev(survived2))) + 
  geom_density_line(bw = 2, alpha = 0.5) + 
  # x축 조정
  scale_x_continuous(name = "나이(세)",  # 이름
                     limits = c(0, 85), # x축의 최소, 최대 범위
                     expand = c(0, 0)) + # 원점에서의 시작, x축 끝의 여백을 최소화하기 위한 expand
  
  scale_y_continuous(name = "등장 횟수", # 이름 
                     limits = c(0, 27), # y축의 최소, 최대 범위 
                     expand = c(0, 0)) + # 원점에서의 시작, y축 끝의 여백을 최소화하기 위한 expand
  
  # plot의 색깔 조정
  scale_fill_manual(name = "생존여부", # 범례 이름
                    values = c("#3399FF", "#FF9933"), # 채움 색깔 설정
                    breaks = levels(Titanicp$survived2)) + # 범례 순서를 위한 breaks
  
  scale_color_manual(name = "생존여부", # 범례이름
                     values = darken(c("#3399FF", "#FF9933"), 0.5), # 라인 색깔 설정
                     breaks = levels(Titanicp$survived2)) + # 범례 순서를 위한 breaks
  
  
  theme_dviz_hgrid() + # background 설정
  # guides(fill = guide_legend(override.aes = list(linetype = 0))) + # 차이를 모르겠는데1
  # coord_cartesian(clip = "on") + # 차이를 모르겠는데2
  theme(
    axis.line.x = element_blank(),
    legend.position = c(.9, .7),
    legend.justification = c("right", "top"),
    legend.box.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(10, 10, 10, 10) # 상, 우, 하, 좌
  )
```


```{r 타이타닉-탑승자의-생존여부에-따른-나이-분포-분할-그래프, fig.cap="타이타닉 탑승자의 생존여부에 따른 나이 분포 분할 그래프"}
# showtext_auto()

Titanicp %>% 
  tidyr::drop_na(age) %>% 
  mutate(survived = factor(survived, levels = c("survived", "died"), labels = c("생존", "사망"))) %>% 
  
# ggplot part
  ggplot(aes(x = age, y = stat(count))) + 
  
  geom_density_line(
    data = select(Titanicp, -survived), aes(fill = "전체 탑승객"),
    color = "transparent"
  ) + 
  geom_density_line(aes(fill = survived), bw = 2, color = "transparent") +
  
  # x축 조정
  scale_x_continuous(name = "탑승객의 나이(세)",  # 이름
                     limits = c(0, 85), # x축의 최소, 최대 범위
                     expand = c(0, 0)) + # 원점에서의 시작, x축 끝의 여백을 최소화하기 위한 expand
  
  scale_y_continuous(name = "등장 횟수", # 이름 
                     limits = c(0, 45), # y축의 최소, 최대 범위 
                     expand = c(0, 0)) + # 원점에서의 시작, y축 끝의 여백을 최소화하기 위한 expand

  scale_fill_manual(
    values = c("#A0A0A0", "#3399FF", "#FF9933"), 
    breaks = c("전체 탑승객", "생존", "사망"),
    labels = c("전체 탑승객", "생존  ", "사망"),
    name = NULL,
    guide = guide_legend(direction = "horizontal")
  ) +
  
  coord_cartesian(clip = "off") +
  
  facet_wrap(~survived) +
  
  theme_dviz_hgrid() +
  
  theme(
    axis.line.x = element_blank(),
    strip.text = element_text(margin = margin(0, 0, 0.2, 0, "cm"),
                              family = "notosanskr",
                              size = 14),
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm"), 
    # facet_wrap으로 생기는 박스 색깔 조정
    # https://stackoverflow.com/questions/19440069/ggplot2-facet-wrap-strip-color-based-on-variable-in-data-set
    strip.background = element_rect(fill="white"),
    
    # # ggplot 내에서 글꼴 변경
    # https://blog.itpaper.co.kr/rdata-graph1-%EC%A0%9C%EB%AA%A9,%EC%B6%95%EC%84%A4%EC%A0%95/
    # https://danbi-ncsoft.github.io/etc/2018/07/24/use-your-font-in-r.html
    # https://statisticsglobe.com/change-font-size-of-ggplot2-plot-in-r-axis-text-main-title-legend
    # text = element_text(family = "notosanskr") # 한번에 변경하기
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16),
    legend.text = element_text(family = "notosanskr", size = 12)
  )
```

## ch 9. 여러 분포 상태의 결합 시각화

### 가로축에 기준을 둔 분포 상태의 시각화 : Sinaplot
jitter + violin ploting을 이용한 방법으로, 관측치가 충분하지 않은 상황에서 사용하기 껄끄럽다는 violin plot의 단점을 개선한 방법이다. 
```{r}
library(ggforce) # geom_sina를 지원한다. 
library(sinaplot) # dataset, blood를 위한 로드
```

```{r Sina-plot-실습-혈액-속-각-클래스에-대한-유전자-농도-분포, fig.cap="혈액 속 각 클래스에 대한 유전자 농도 분포"}
blood %>% 
  
  ggplot(aes(x = Class, y = Gene)) +
  geom_violin(color = "transparent", fill = "#A0A0A0") + 
  geom_sina(size = 1) + 

  theme(plot.margin = margin(3, 7, 3, 1.5), 
        axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.title.x = element_text(family = "notosanskr", size = 16),
        axis.title.y = element_text(family = "notosanskr", size = 16))
```


### 세로축에 기준을 둔 분포 상태의 시각화 : ridgeline plot 

```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "70_20")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

```{r ridgeline-plot-실습, fig.cap="70년부터 19년까지 한국 전체 월별 평균 기온과 서울과 부산의 월별 평균기온의 차이에 대한 분포"}
# 70년부텨 20년 7월까지, 서울과 광역시, 제주시의 월별 평균 기온 데이터 불러오기
# https://data.kma.go.kr/cmmn/main.do 참고 
# http://drtagkim.blogspot.com/2019/02/r-csv.html : 한글 꺠져서 나오는 문제 
ROK_70_20 <- read_csv("한국_주요시_평균기온_70_20까지.csv", locale=locale('ko',encoding='euc-kr'))

ROK_70_20 %>% 
  select(-`지점`) %>% 
  mutate(`일시` = parse_date(`일시`, format = "%Y-%m")) %>% 
  mutate(`연도` = year(`일시`)) %>% 
  filter(`연도` < 2020) %>% 
  
  dplyr::group_by(`일시`) %>% 
  dplyr::mutate(`월 별 전체 평균` = mean(`평균기온(°C)`)) %>% 
  ungroup() %>% 
  
  mutate(`기온 차이(°C)` = `평균기온(°C)` - `월 별 전체 평균`) %>% 
  filter(`지점명` == "서울" | `지점명` == "부산") %>% 
  
  
  ggplot(aes(x = `기온 차이(°C)`, y = `연도`, 
             group = interaction(`지점명`, factor(`연도`)),
             fill = interaction(`지점명`, factor(`연도`))
             )) + 
  geom_density_ridges(scale = 5, size = 0.25, rel_min_height = 0.01, alpha=0.9, color = "white") + 
  scale_x_continuous(
    name = "지역 평균 기온 - 전체 평균 기온",
    limits = c(-6, 6),
    breaks = seq(-6, 6, 1)
  ) +
  scale_y_reverse(
    name = "연도",
    expand = c(0, 0), breaks=c(seq(2019, 1970, -10))
  ) +
  scale_fill_cyclical(
    breaks = c("서울.1970", "부산.1970"),
    labels = c(`서울.1970` = "서울특별시", `부산.1970` = "부산광역시"),
    values = c("#ff8000", "#0080ff", "#ff9933", "#3399ff"),
    name = NULL,
    guide = "legend"
  ) + 
  theme_dviz_grid() +
  theme(
    axis.text.y = element_text(vjust = 0),
    legend.position = c(1, 1),
    legend.justification = c(1, 1),
    legend.direction = "horizontal",
    legend.background = element_rect(fill = "white"),
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16)
  )
  
```



```{r, eval=FALSE, include=FALSE}
# KGSS 데이터 로드 후 data.frame으로 변환
# KGSS는 spss 파일로 제공됨
df <- as.data.frame(read.spss("2003-2018_KGSS_public_v3.sav", reencode='utf-8'))
head(df)


df %>% 
  as.tibble() %>% 
  filter(YEAR == 2018) %>% 
  select(YEAR, AGE, MARITAL, HEALTHY) %>% 
  mutate(AGE = 
           as.numeric(
             str_remove(
               as.character(AGE), "세"
             )
           )
  ) -> df

write.csv(df, file = "KGSS_2018_edit.csv", row.names = TRUE)
```

```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "KGSS")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

```{r KGSS-HEALTHY-density-plot, fig.cap="2018년 KGSS 데이터를 바탕으로 그린 연령별 건강 상태 분포 플롯"}
KGSS_2018_edit <- read_csv("KGSS_2018_edit.csv", locale=locale('ko',encoding='euc-kr'))

KGSS_2018_edit %>% 
  filter(HEALTHY != "DK")  %>% 
  mutate(HEALTHY = factor(HEALTHY, 
                          levels = c("매우 좋다", "다소 좋다", "좋지도 나쁘지도 않다", "다소 나쁘다", "매우 나쁘다"))) %>% 
  
  # ggplot 파트 시작
  ggplot(aes(x = AGE, y = ..count..)) +
  geom_density_line(data = select(KGSS_2018_edit, -HEALTHY), aes(fill = "응답 인원 전체"), color = "transparent") +
  
  geom_density_line(aes(fill = "강조 그룹"), color = "transparent") +
  
  facet_wrap(~HEALTHY, nrow = 1) +
  
  scale_x_continuous(name = "나이(세)", limits = c(18, 97), expand = c(0, 0)) +
  scale_y_continuous(name = "빈도 수", expand = c(0, 0)) +
  scale_fill_manual(
    values = c("#2b8cbed0", "#b3b3b3a0"),
    name = NULL,
    guide = guide_legend(direction = "horizontal", reverse = TRUE)
  ) +
  
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  
  theme(
    axis.line.x = element_blank(),
    
    strip.text = element_text(size = 14, margin = margin(0, 0, 0.2, 0, "cm"), family = "notosanskr"),
    strip.background = element_rect(fill="white"), 
    
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm"), 
    legend.text = element_text(family = "notosanskr", size = 12), 
    
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16)
  )
```
굉장히 소박한 빈도수를 가진 density plot이 나왔다. 전체 천 명 가량되는 집단을 5개로 나누고, 연령대가 아닌 각 연령으로 구분해서 그런 것으로 보인다. 

```{r KGSS-MARITAL-density-plot, fig.cap="2018년 KGSS 데이터를 바탕으로 그린 연령별 결혼 상태 분포 플롯"}
KGSS_2018_edit <- read_csv("KGSS_2018_edit.csv", locale=locale('ko',encoding='euc-kr'))

KGSS_2018_edit %>% 
  filter(!MARITAL %in% c("DK", "동거", "별거")) %>% 
  mutate(MARITAL = factor(MARITAL, 
                          levels = c("미혼", "기혼", "이혼", "사별"))) %>% 
  
  # ggplot 파트 시작
  ggplot(aes(x = AGE, y = ..count..)) +
  geom_density_line(data = select(KGSS_2018_edit, -MARITAL), aes(fill = "응답 인원 전체"), color = "transparent") +
  
  geom_density_line(aes(fill = "강조 그룹"), color = "transparent") +
  
  facet_wrap(~MARITAL, nrow = 1) +
  
  scale_x_continuous(name = "나이(세)", limits = c(18, 97), expand = c(0, 0)) +
  scale_y_continuous(name = "빈도 수", expand = c(0, 0)) +
  scale_fill_manual(
    values = c("#2b8cbed0", "#b3b3b3a0"),
    name = NULL,
    guide = guide_legend(direction = "horizontal", reverse = TRUE)
  ) +
  
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  
  theme(
    axis.line.x = element_blank(),
    
    strip.text = element_text(size = 14, margin = margin(0, 0, 0.2, 0, "cm"), family = "notosanskr"),
    strip.background = element_rect(fill="white"), 
    
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm"), 
    legend.text = element_text(family = "notosanskr", size = 12), 
    
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16)
  )
```


```{r relative-ratio-densitiy-plot, fig.cap="2018년 KGSS 데이터의 상대 비율을 바탕으로 그린 연령별 결혼 상태 분포 플롯"}
KGSS_2018_edit <- read_csv("KGSS_2018_edit.csv", locale=locale('ko',encoding='euc-kr'))

KGSS_2018_edit %>% 
  filter(!MARITAL %in% c("DK", "동거", "별거")) %>% 
  mutate(MARITAL = factor(MARITAL, 
                          levels = c("미혼", "기혼", "이혼", "사별"))) %>% 
  select(AGE, MARITAL) -> KGSS_2018_edit


# 5번의 mutate의 결과를 rbind로 쌓아서 4개의 플롯 + 배경 플롯을 그림.  
rbind(
  mutate(KGSS_2018_edit,
         MARITAL = as.character(fct_collapse(MARITAL, `미혼` = "미혼", aother = c("기혼", "이혼", "사별"))),
         highlight = "미혼"
  ),
  mutate(KGSS_2018_edit,
         MARITAL = as.character(fct_collapse(MARITAL, `기혼` = "기혼", aother = c("미혼", "이혼", "사별"))),
         highlight = "기혼"
  ),
  mutate(KGSS_2018_edit,
         MARITAL = as.character(fct_collapse(MARITAL, `이혼` = "이혼", aother = c("미혼", "기혼", "사별"))),
         highlight = "이혼"
  ),
  mutate(KGSS_2018_edit,
         MARITAL = as.character(fct_collapse(MARITAL, `사별` = "사별", aother = c("미혼", "기혼", "이혼"))),
         highlight = "사별"
  )
) %>%
  mutate(
    highlight = factor(highlight, levels = c("미혼", "기혼", "이혼", "사별"))
  ) -> KGSS_2018_edit


# ggplot 시작
ggplot(KGSS_2018_edit, aes(AGE)) +
  
  # 배경 구획 및 색깔 지정
  annotate(geom = "rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, fill = "#b3b3b3a0", color = NA) +
  
  # geom_density_line
  geom_density_line(
    aes(y = stat(count), fill = MARITAL), color = "transparent", position = "fill"
  ) +
  
  # highlight 기준으로 펼치기
  facet_wrap(~highlight, nrow = 1) +
  
  scale_x_continuous(
    name = "나이(세)",
    limits = c(18, 98),
    expand = c(0, 0)
  ) +
  scale_y_continuous(name = "상대 비율", expand = c(0, 0), labels = scales::percent) +
  
  scale_fill_manual(
    values = c("transparent", "#2b8cbed0", "#2b8cbed0", "#2b8cbed0", "#2b8cbed0"),
    name = NULL,
    breaks = c("aother", "이혼"),
    labels = c("응답 인원 전체  ", "강조 그룹"),
    guide = guide_legend(
      direction = "horizontal",
      override.aes = list(fill = c("#bebebe", "#3590c0"))
    )
  ) +
  coord_cartesian(clip = "off") +
  theme_dviz_hgrid() +
  theme(
    axis.line.x = element_blank(),
    strip.text = element_text(size = 14, margin = margin(0, 0, 0.2, 0, "cm")),
    strip.background = element_rect("white"),
    legend.position = "bottom",
    legend.justification = "right",
    legend.margin = margin(4.5, 0, 1.5, 0, "pt"),
    legend.spacing.x = grid::unit(4.5, "pt"),
    legend.spacing.y = grid::unit(0, "pt"),
    legend.box.spacing = grid::unit(0, "cm"), 
    legend.text = element_text(family = "notosanskr", size = 12), 
    
    axis.title.x = element_text(family = "notosanskr", size = 16),
    axis.title.y = element_text(family = "notosanskr", size = 16)
  )
```


## ch 11 비율 데이터를 내포 형태로 시각화

내포 비율(nested proportion)은 관측치들이 여러 범주형 변수에 대한 비율을 의미하는 단어이다. 예를 들어 20-30대 시민 100명의 성별, 학력, 직업, 거주 지역 등을 조사한 데이터셋이 있다고 하자. 이 때, 100명의 시민에 대한 4개의 범주형 변수를 한 번에 시각화하려면 각각의 범주형 변수의 경우의 수를 계산한 후 비율로 정리하면 내포 비율을 구할 수 있다. 즉, **다양한 변수들이 중첩된 비율**이라고 이해하면 된다. 

책에서는 파이 차트, 트리맵, 평행 집합 플롯 등을 소개하고 있는데 트리맵과 평행 집합 플롯은 그려본 적이 없어 직접 그려보며 해석과 코드 작성 연습을 해보려 한다. 

### Treemap

모자이크 플롯과 비슷한 트리맵은 형태의 차이를 보일 뿐 비슷한 형식과 목적을 갖는다. 그럼에도 예시로 제시된 그림에서 트리맵이 좀 더 많은 정보를 비교적 명확하게 보일 수 있다고 판단했기 때문에 트리맵을 연습해보려고 한다. 예제와 비슷하게 한국의 도별 주요 시들의 면적 대비 인구수 데이터를 이용해보았다. 


```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "행정구역")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}

pop_si_kr <- read_csv("행정구역_시군구_별__성별_인구수_20200828223639.csv", locale=locale('ko',encoding='euc-kr'), skip = 1)
```

```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "도시지역면적")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
area_si_kr <- read_csv("도시지역면적_시도_시_군_구__20200829004719.csv", locale=locale('ko',encoding='euc-kr'))
names(area_si_kr) <- c("행정구역(시군구)별", "면적")
```


```{r treemap연습-행정구역과-도시지역면적-데이터-합치기}
# pop_si_kr : 대한민국의 도별 주요 시의 인구 수
# area_si_kr : 대한민국의 도별 주요 시의 면적

left_join(pop_si_kr, area_si_kr, by = "행정구역(시군구)별") %>% 
  drop_na() %>% 
  select(`행정구역(시군구)별`, `총인구수 (명)`, 면적) %>% 
  # mutate(대분류 = seq(1, nrow(.), 1)) %>% 
  mutate(대분류 = rep(c("경기도", "강원도", "충청북도", "충청남도", "전라북도", "전라남도", "경상북도", "경상남도"), 
                   c(28, 8, 4, 9, 7, 6, 11, 9))) %>% 
  dplyr::group_by(대분류, `행정구역(시군구)별`) %>% 
  dplyr::summarise(`총인구수 (명)` = sum(`총인구수 (명)`), 
                   면적 = sum(면적)) %>% 
  ungroup() %>% 
  dplyr::filter(!str_detect(`행정구역(시군구)별`, "도$")) %>% 
  mutate(across(where(is.character), as.factor)) -> pop_area_kr
```

```{r treemap연습-색깔-추가한-데이터셋-만들기}
## manually add colors
# hues
# hues <- c(300, 50, 250, 100) # purple, brown, blue, green
hues <- seq(50, 400, 50) # brown, green, blue, purple

# minimum and maximum population density
minpop <- min(pop_area_kr$`총인구수 (명)`)
maxpop <- max(pop_area_kr$`총인구수 (명)`)

# turn pop density into color
pop_area_kr %>%
  mutate(index = as.numeric(factor(대분류))) %>%
  group_by(index) %>%
  mutate(
    value = (`총인구수 (명)`-minpop)/(maxpop-minpop)
    # scale_fill_identity에서 문제가 생겼으므로 value로 alpha를 조절해서 표현하는 방법으로 수정함
    # fill이 의미가 없어짐. 
    # fill = scales::gradient_n_pal(
    #   colorspace::sequential_hcl(
    #     6,
    #     h = hues[index],
    #     c = c(45, 20),
    #     l = c(30, 80),
    #     power = .5
    #   )
    # )(1-value)
  ) -> pop_area_kr_color
```

```{r treemap연습-treemap-그리기-원래코드, eval=FALSE, include=FALSE}

# 문제점 : scale_fill_identity을 실행하면 전체 subgroup의 색이 통일되어버림. 
# 해결방법을 찾아볼 것. 사실 R studio에서 실행하면 실행되는데 knit을 이용하면 색깔이 바뀌어버림. 
# 왜 knit로만 실행하면 결과가 바뀌는 걸까? 
ggplot(pop_area_kr_color, aes(area = 면적, subgroup = 대분류, fill = fill)) +
  geom_treemap(color = "white", size = 0.5*.pt, alpha = NA) + 
  geom_treemap_subgroup_text(
    # family = dviz_font_family,
    colour = "white",
    place = "centre", alpha = 0.7,
    grow = TRUE
  ) +
  geom_treemap_subgroup_border(color = "white") +
  geom_treemap_text(
    aes(label = `행정구역(시군구)별`),
    color = "black",
    # family = dviz_font_family,
    place = "centre",
    grow = FALSE
  ) +
  scale_fill_identity() +
  coord_cartesian(clip = "off") +
  guides(colour = "none", fill = "none")
```


```{r treemap연습-treemap-그리기, fig.cap="대한민국의 도별, 대표 시들의 면적대비 인구 수를 나타낸 트리맵"}
library(ggplot2)
pop_area_kr_color

pop_area_kr_color %>% 
  ggplot(aes(area = 면적, subgroup = 대분류, fill = 대분류)) +
  geom_treemap(color = "white", size = 0.5*.pt, aes(alpha = value)) + 
  geom_treemap_subgroup_text(
    colour = "white",
    place = "centre", alpha = 0.7,
    grow = TRUE
  ) +
  geom_treemap_subgroup_border(color = "white") +
  geom_treemap_text(
    aes(label = `행정구역(시군구)별`),
    color = "black",
    place = "centre",
    grow = FALSE
  ) +
  coord_cartesian(clip = "off") +
  scale_alpha_continuous(range = c(0.2, 1)) + 
  theme(legend.position = "none")
```


### Parallel set

Parallel set, 평행 집합 플롯은 잘 그리면 정말 "있어보이는" 그림이다. 과거 본 그림은 문, 강, 목을 표현한 평행 집합 플롯이었는데 범주형 변수에 따라 추세를 볼 수 있어서 기억에 남아 있다. 한 번 그려보고 싶어서 문화유적 데이터를 이용해보았다. 

```{r, include=FALSE}
data_in_drive <- drive_find(type = "csv", pattern = "향토")

for(i in 1:1){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```

```{r parallel-set-연습, fig.cap="전국향토문화유적표준데이터를 이용한 평행 집합 플롯"}
remains <- read_csv("전국향토문화유적표준데이터.csv", locale=locale('ko',encoding='euc-kr'))

remains %>% 
  filter(str_detect(향토문화유적종류, "^건조물$|^유형문화유적$|^옛무덤$|^묘$|^기념물$")) %>%
  select(향토문화유적구분, 향토문화유적종류, 소유주체구분) %>% 
  mutate(across(where(is.character), as.factor)) %>% 
  dplyr::count(향토문화유적구분, 향토문화유적종류, 소유주체구분) %>% 
  gather_set_data(., 1:3) %>% 
  mutate(x = factor(x, levels = c("향토문화유적구분", "향토문화유적종류", "소유주체구분"))) %>% 
  
  ggplot(aes(x, id = id, split = y, value = n)) +
  
  # https://ggforce.data-imaginist.com/reference/geom_parallel_sets.html
  geom_parallel_sets(aes(fill = 향토문화유적구분), alpha = 0.5, axis.width = 0.13) +
  geom_parallel_sets_axes(axis.width = 0.1, fill = "grey80", color = "grey80") +
  geom_parallel_sets_labels(
    color = 'black',
    size = 10/.pt,
    angle = 90
  ) +
  scale_x_discrete(
    name = NULL,
    expand = c(0, 0.2)
  ) +
  scale_y_continuous(breaks = NULL, expand = c(0, 0))+
  scale_fill_manual(
    values = c("#CC79A7D0", "#56B4E9D0", "#F0E442D0"),
    guide = "none"
  ) +
  theme(
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    plot.margin = margin(14, 1.5, 2, 1.5)
  )
```




