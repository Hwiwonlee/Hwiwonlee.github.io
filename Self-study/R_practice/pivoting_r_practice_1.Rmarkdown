---
title: "Tidyverse와 pivoting"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
mainfont: NanumGothic
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                        collapse = TRUE, comment = "#>")


library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
```

# Pivoting?
사전에서 **pivot**을 찾으면 (축을 중심으로) 회전하다; 회전시키다의 정의를 찾을 수 있듯이, 데이터 핸들링에서의 **pivoting**은 데이터셋을 **어떠한 기준**에 따라 넓게 펴보거나 길게 좁혀보는 방법을 뜻합니다. pivoting의 아주 좋은 예시를 `tidyr`의 로고에서 찾을 수 있습니다. 

```{r, fig.cap="tidyr의 로고. 행과 열의 기준에 따라 데이터셋의 형태를 바꾸는 pivoting을 보여주고 있다"}
knitr::include_graphics("https://tidyr.tidyverse.org/logo.png")
```

[tidyr의 메인 페이지에서 볼 수 있는 것](https://tidyr.tidyverse.org/index.html)과 같이 pivoting은 tidyr의 다섯 가지 핵심 기능 중 하나입니다. 다섯 가지를 간단히 나열해보면 아래와 같습니다.    

  * 데이터셋을 세로형 혹은 가로형으로 변환하는 pivoting의 `pivot_longer()`, `pivot_wider()`
  * 여러 수준으로 이뤄진 리스트를 tibble의 행과 열로 정리하는 Rectangling의 `unnest_longer()`, `unnest_wider()`, `unnest_auto()`, `hoist()`
  * 중첩된 데이터 프레임을 다루는 `nest()`, `unnest()`
  * 문자열을 값으로 갖는 열을 다루는 `separate()`, `extract()`, `unite()`
  * 결측치를 다루는 `complete()`, `drop_na()`, `fill()`, `replace_na()`
  
pivoting은 `pivot_longer()`, `pivot_wider()`이 아닌 `gather()`과 `spread()` 혹은 `melt()`와 `dcast()`를 사용해도 할 수 있는 작업입니다. 그러나  [**pivoting**](https://tidyr.tidyverse.org/articles/pivot.html) 페이지에서 `pivot_longer()`, `pivot_wider()`을 사용하면 좀 더 편리하고 직관적으로 pivoting할 수 있다고 하고 제 개인적으로도 `pivot_` 시리즈를 사용하는 것이 더 편했기 때문에 이 함수를 더 알아보자는 차원에서 포스트를 작성하게 되었습니다. 이제 예제를 통해 `pivot_longer()`와 `pivot_wider()`의 사용법을 알아보도록 하겠습니다. 


# Longer
`pivot_longer()`은 데이터셋의 여러 변수들을 하나의 변수로 중첩시켜 **세로로 긴 형태의 데이터셋**으로 만드는 함수입니다. **세로로 긴 형태의 데이터셋**, 즉 세로형 데이터셋이 필요한 대표적인 경우는 **여러 변수들을 하나의 명목형 변수**(categorical variable 혹은 factor)**로 만들 수 있을 때**입니다. 천 명의 신용평가자료인 `GermanCredit` 데이터셋을 이용해서 설명해보겠습니다. 

```{r}
library(caret)
data(GermanCredit)
GermanCredit # 1000 x 62
```
```{r}
names(GermanCredit)
```
62개의 열을 갖고 있는 `GermanCredit`의 열 이름에 일정한 규칙이 있음을 찾으셨나요? 여러 번 데이터셋을 분석해보신 분이라면 `변수의 이름.변수의 수준`으로 구성되어 있음을 쉽게 보실 수 있으실 겁니다. 예를 들어 대출 목적을 의미하는 `Purpose`의 경우, `Newcar`, `UsedCar`, `Furniture.Equipment`, `Radio.Television`, ... 등으로 합칠 수 있겠습니다. 한번 볼까요? 
```{r}
GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>% 
  pivot_longer(cols = matches("Purpose"), 
               names_to = "Purpose", 
               values_to = "Purpose value",
               names_prefix = "Purpose.") %>% 
  select(index, Purpose, `Purpose value` , everything())
```



# Wider 

