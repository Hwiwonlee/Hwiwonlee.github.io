---
title: "Tidyverse와 pivoting"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
mainfont: NanumGothic
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                        collapse = TRUE, comment = "#>")

# https://tibble.tidyverse.org/reference/formatting.html
options(tibble.print_max = 10)
options(tibble.max_extra_cols = 5)
options(max.print = 300)

library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
```

# Pivoting?
사전에서 **pivot**을 찾으면 (축을 중심으로) 회전하다; 회전시키다의 정의를 찾을 수 있듯이, 데이터 핸들링에서의 **pivoting**은 데이터셋을 **어떠한 기준**에 따라 넓게 펴보거나 길게 좁혀보는 방법을 뜻합니다. pivoting의 아주 좋은 예시를 `tidyr`의 로고에서 찾을 수 있습니다. 

> 1.1.1의 tidyr에서 로고가 바뀌었습니다. 아래의 로고는 1.1이하의 로고입니다.


```{r, echo=FALSE, out.height="30%", out.width="30%" , fig.cap="tidyr의 로고. 행과 열의 기준에 따라 데이터셋의 형태를 바꾸는 pivoting을 보여주고 있다"}
knitr::include_graphics("https://ih1.redbubble.net/image.543365563.2254/flat,750x1000,075,f.u2.jpg", dpi = 300)
```

[tidyr의 메인 페이지에서 볼 수 있는 것](https://tidyr.tidyverse.org/index.html)과 같이 pivoting은 tidyr의 다섯 가지 핵심 기능 중 하나입니다. 다섯 가지를 간단히 나열해보면 아래와 같습니다.    

  * 데이터셋을 세로형 혹은 가로형으로 변환하는 pivoting의 `pivot_longer()`, `pivot_wider()`
  * 여러 수준으로 이뤄진 리스트를 tibble의 행과 열로 정리하는 Rectangling의 `unnest_longer()`, `unnest_wider()`, `unnest_auto()`, `hoist()`
  * 중첩된 데이터 프레임을 다루는 `nest()`, `unnest()`
  * 문자열을 값으로 갖는 열을 다루는 `separate()`, `extract()`, `unite()`
  * 결측치를 다루는 `complete()`, `drop_na()`, `fill()`, `replace_na()`
  
pivoting은 `pivot_longer()`, `pivot_wider()`이 아닌 `gather()`과 `spread()` 혹은 `melt()`와 `dcast()`를 사용해도 할 수 있는 작업입니다. 그러나  [**pivoting**](https://tidyr.tidyverse.org/articles/pivot.html) 페이지에서 `pivot_longer()`, `pivot_wider()`을 사용하면 좀 더 편리하고 직관적으로 pivoting할 수 있다고 하고 제 개인적으로도 `pivot_` 시리즈를 사용하는 것이 더 편했기 때문에 이 함수를 더 알아보자는 차원에서 포스트를 작성하게 되었습니다. 이제 예제를 통해 `pivot_longer()`와 `pivot_wider()`의 사용법을 알아보도록 하겠습니다. 


# Longer
## 예제를 통해 알아보는 `pivot_longer()`의 효과
`pivot_longer()`은 데이터셋의 여러 변수들을 하나의 변수로 중첩시켜 **세로로 긴 형태의 데이터셋**으로 만드는 함수입니다. **세로로 긴 형태의 데이터셋**, 즉 세로형 데이터셋이 필요한 대표적인 경우는 **여러 변수들을 하나의 명목형 변수**(categorical variable 혹은 factor)**로 만들 수 있을 때**입니다. 천 명의 신용평가자료인 `GermanCredit` 데이터셋을 이용해서 설명해보겠습니다. 

```{r}
library(caret)
data(GermanCredit)
tibble(GermanCredit) # 1000 x 62
```
62개의 열을 갖고 있는 `GermanCredit`의 열 이름에 일정한 규칙이 있음을 찾으셨나요? 여러 번 데이터셋을 분석해보신 분이라면 `변수의 이름.변수의 수준`으로 구성되어 있음을 쉽게 보실 수 있으실 겁니다. 예를 들어 대출 목적을 의미하는 `Purpose`의 경우, `Newcar`, `UsedCar`, `Furniture.Equipment`, `Radio.Television`, ... 등으로 합칠 수 있겠습니다. 한번 볼까요? 
```{r}
GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>%  
  pivot_longer(cols = matches("Purpose"), # 하나의 열로 길게 합칠 열들을 선택하고
               names_to = "Purpose", # `하나의 열`의 이름을 정해준 다음
               names_prefix = "Purpose.", # `하나의 열`에 들어갈 합쳐질 열의 이름들에서 빼고 싶은 부분을 정해주고
               values_to = "Purpose value") %>% # 길게 합쳐질 열들이 갖고 있던 값이 저장될 열의 이름까지 설정해주면 끝.
  select(index, Purpose, `Purpose value` , everything())
```
위의 `pivot_longer()`의 결과물로 당장 확인할 수 있는 것은 아래의 세 개 정도가 될 것 같습니다. 

  * `Purpose`와 `Purpose value`  
    - `Purpose`에는 `Purpose.`가 붙어있던 항목들이 열로 저장  
    - `Purpose value`에는 `Purpose.항목`의 값이 열로 저장  
  * `index` 그리고 `Duration`부터 `Age`까지의 값이 같음   
  * 데이터셋의 행과 열의 개수  
    - 행은 1000에서 11000개로, 열은 62개에서 54개로 바뀜  

하나 하나씩 살펴보겠습니다. 먼저 `Purpose`에 정말 `Purpose.`가 붙어있던 항목들이 저장되어 있는지 확인해보겠습니다. 위의 코드에 `count()`만 더해주면 간단하게 확인 가능하겠죠? 
```{r, echo=FALSE}
options(tibble.print_max = 11)
GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>%  
  pivot_longer(cols = matches("Purpose"), 
               names_to = "Purpose", 
               names_prefix = "Purpose.", 
               values_to = "Purpose value") %>% 
  select(index, Purpose, `Purpose value` , everything()) %>% 
  count(Purpose)
```
`Purpose`에 `Business`부터 `Vacation`까지 처음 데이터셋의 row 개수와 같은 1000개씩 저장되어 있는 것을 확인할 수 있습니다. 


```{r}
GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>%  
  pivot_longer(cols = matches("Purpose"), 
               names_to = "Purpose", 
               names_prefix = "Purpose.", 
               values_to = "Purpose value") %>% 
  select(index, Purpose, `Purpose value` , everything()) %>% 
  filter(`Purpose value` != 0 & index <= 10) %>% 
  select(index, Purpose, `Purpose value`) -> check # pivot_longer의 결과에서 1:10 rows의 결과만 저장

GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>% 
  select(index, matches("purpose")) %>% 
  inner_join(check, ., by = "index") %>%  # inner_join을 통해 check와 pivot_longer이전의 데이터 결합
  as.data.frame()
```
마찬가지로 `Purpose value`에 `Purpose.`가 붙어있었던 열의 값, 1이 저장되어있음을 볼 수 있습니다. 만약 이 시점에서 데이터로 분석을 할 것이라면 `Purpose value`의 가치는 없어졌기 때문에 `Purpose value`를 삭제할 수 있습니다. 이미 `Purpose`에 **대출의 목적**이 명목형 변수로 저장되어 있기 때문입니다. (물론, `pivot_longer()` 전의 `Purpose.대출목적`이 특별한 값을 갖는다면 지금처럼 `Purpose value`를 삭제해줄 수 없습니다.) 이와 같이 데이터셋 안에 퍼져있는 여러 개의 열과 그 열이 가진 값들을 합쳐 세로로 쌓는 것이 `pivot_longer()`의 효과입니다. 

`pivot_longer()`의 효과를 설명했으니 두 번째와 세 번째는 더욱 쉽게 확인해볼 수 있습니다. `pivot_longer()`를 사용해 열들을 세로로 길게 쌓게 되면 대상이 된 열만큼 나머지 열들의 값이 행에 복사됩니다. 경우의 수를 생각해보면 이해가 쉽습니다. 하나의 obs이 하나의 행을 가진 상태에서 `pivot_longer()`로 생긴 열의 경우의 수 만큼, 하나의 obs가 갖는 행이 늘어나게 되는 것이죠. 

```{r}
options(tibble.print_max = 11)
GermanCredit %>% 
  mutate(index = seq(1, 1000, 1)) %>%  
  pivot_longer(cols = matches("Purpose"), 
               names_to = "Purpose", 
               names_prefix = "Purpose.", 
               values_to = "Purpose value") %>% 
  select(index, Purpose, `Purpose value` , everything()) %>% 
  filter(index == 1)
```
`pivot_longer()`에서 각 obs가 고유한 값을 갖는 `index == 1`만 추출한 결과입니다. `pivot_longer()`을 하기 전엔 index당 하나의 행을 가졌지만 `pivot_longer()`후에는 `Purpose`에 저장된 11개의 값 만큼 증가한 11개의 행을 갖고 있음을 볼 수 있습니다. 더하여, `Purpose`와 `Purpose_value`의 차이만 있을 뿐 나머지 열의 값에는 차이가 없음 또한 볼 수 있습니다.  
`pivot_longer()`후에 행의 개수가 늘어난 것이 바로 이러한 이유 때문입니다. 단순히 `11*1000`해서 증가한 것이죠. 추가된 `Purpose`열로 `Pupose.목적`의 열이 들어갔으니 11개의 열이 줄었고 `Purpose`와 `Purpose_value`가 생겼으니 2개의 열이 늘어서 총 9개의 열이 줄어든 53개의 열을 갖게 되는 것입니다(`index`는 제가 임의로 추가한 것이라 제외했습니다).

예제 데이터를 통해 `pivot_longer()` 효과를 살펴보았습니다. 이제 `pivot_longer()`을 좀 더 잘 쓰기 위해 `pivot_longer()`가 가진 argument와 효과를 알아보겠습니다. 

## `pivot_longer()`의 argument
```{r}
# pivot_longer(
#     data, # dataset  
#     cols, # 필수, pivot_longer()의 타겟이 되는 열을 지정합니다.   
#     names_to = "name", # 대상이 된 열들이 저장될 열의 이름을 지정합니다.   
#     names_prefix = NULL, # 대상이 된 열들의 이름에서 제외할 문자열을 지정합니다.   
#     names_sep = NULL, # 대상이 된 열들의 이름이 가진 구분자를 정의해줍니다.   
#     names_pattern = NULL, # 대상이 된 열들의 이름이 가진 패턴을 정의해줍니다.   
#     names_ptypes = list(), # 대상이 된 열들이 저장될 열의 prototype을 정의해줍니다.   
#     names_transform = list(), # 대상이 된 열들이 저장될 열의 type을 정의해줍니다.   
#     names_repair = "check_unique", # 대상이 된 열들의 이름이 겹치는 경우, 에러를 방지하기 위한 설정값입니다.   
#     values_to = "value", # 대상이 된 열들이 갖고 있는 값이 저장될 열의 이름을 지정합니다.   
#     values_drop_na = FALSE, # 대상이 된 열들에 NA가 포함된 경우 drop 여부를 결정합니다.   
#     values_ptypes = list(), # 대상이 된 열들이 갖고 있는 값이 저장될 열의 prototype을 정의해줍니다.   
#     values_transform = list(), # 대상이 된 열들이 갖고 있는 값이 저장될 열의 type을 정의해줍니다.   
#     ...  
# )
```









# Wider 
