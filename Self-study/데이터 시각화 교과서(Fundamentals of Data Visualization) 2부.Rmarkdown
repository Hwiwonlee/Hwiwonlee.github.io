---
title: "데이터 시각화 교과서(Fundamentals of Data Visualization) 2부"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
categories:
  - visualization
tags:
  - R
  - visualization
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
      css: "post_style.css"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                      comment = "#>")

# https://tibble.tidyverse.org/reference/formatting.html
options(tibble.print_max = 10)
options(tibble.max_extra_cols = 5)
# options(max.print = 300)

library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
library(googledrive) # Import dataset from the google drive
library(readr) # To read csv file
library(lubridate)
library(operators)
library(magrittr)
library(ggridges) # geom_density_line()을 위한 패키지 로드
library(tinter) # darken()을 위한 패키지 로드
library(pkgsimon) # theme_dviz_hgrid()를 위함
library(showtext)
font_add_google('Noto Sans KR', 'notosanskr')
font_add_google('Noto Sans', 'notosans')
font_add_google('Nanum Gothic', 'nanumgothic')
library(ggforce) # sina plot을 위한 패키지 
# library(dviz.supp) # colorblindr가 4.0.2에서 사용 불가해서 설치가 안됨 
library(foreign)
library(treemapify) # geom_treemap
library(ggrepel) # geom_text_repel
library(ggfortify) # auto_plot for PCA plot 


library(gapminder)
library(colorspace)
```




ch 17 잉크 양 비례의 원칙

**잉크 양 비례의 원칙**(principle of proportinal ink)라는 다소 낯선 개념이 등장한다. 정의는 아래와 같다. 

> The principle of proportional ink: The sizes of shaded areas in a visualization need to be proportional to the data values they represent(색조를 넣은 영역이 수치 값을 나타낼 때, 색조가 들어간 영역의 면적은 해당 값과 정비례해야 한다).

번역본의 주석에 따르면 원래의 정의는 이렇다고 한다. 

> The representation of numbers, as physically measured on the surface of the graphic itself, should be directly proportional to the numerical quantities represented(그래픽 자체의 표면에 숫자를 물리적으로 표현하는 경우, 수치의 크기와 표면적의 넓이는 정비례해야 한다). 


잉크 양 비례의 원칙이라는 말이 와닿지 않아서 그렇지 의미를 보면 그래프를 그리는 사람들 모두가 알고 있는 사실이다. **숫자와 면적이 정비례하게 그릴 것.** 잉크 양 비례의 원칙을 위배한 유명한 예시가 있다.

```{r wrong-pie-chart, echo = FALSE, fig.cap = "JTBC의 유명한 파이차트. 숫자와 해당 카테고리를 의미하는 면적이 일치하지 않으며 심지어 비례하지도 않는다."}
include_graphics("https://www.mediawatch.kr/data/photos/20170312/art_14899947314124_cfb2da.jpg")
```

JTBC 뉴스룸에서 방송된 파이차트([출처](https://www.mediawatch.kr/news/article.html?no=251671))로 대단히 놀라운 수준의 시각화를 보여준다. `잘했다`, `모르겠다`, `잘못했다` 세 범주로 나눠진 설문조사 응답은 차례대로 `64.0%`, `28.7%`, `7.3%`이지만 그래프의 면적은 `잘했다 >= 잘못했다 > 모르겠다`로 보인다. 이 파이차트에서 정확한 것은 설문조사의 응답 범주 뿐이고 나머지는 모두 틀렸다고 봐도 무방하다. 

이렇게 그리지 말라는 것이다. 

책에서는 대부분의 사람들이 한 번 정도는 실수했던 부분에 대해서도 얘기한다. **그래프 축의 시작은 반드시 0이어야 한다.**가 바로 그것이다. 물론, 목적이나 분야에 따라 시작점이 **반드시** 0이 되지 않아도 되는 경우가 있긴 하다. 가령 주가를 다룬 시계열 그래프나 대중 매체에서 사용되는 그래프들이 그렇다. 

하지만 그래프의 축이 0부터 시작하지 않는다면 시각화의 왜곡은 반드시 일어난다. 책에 나온 경우를 표현하기 위해 `gapminder` 데이터셋의 인구 수
를 사용해보았다. 

```{r wrong-bar-plot, fig.cap="2007년 기준 인구 수(백만 명 단위)"}
gapminder %>% 
  filter(continent == "Asia", 
         year == "2007") %>% 
  mutate(pop_million = pop / 1000000) %>% 
  filter(between(pop_million, 20, 60)) %>% 
  
  ggplot(aes(x = country, y = pop_million)) + 
  geom_col(fill = "#FF9436") + 
  coord_cartesian(ylim = c(20, 55), expand = FALSE) + 
  scale_y_continuous(
    name = "Population per million", 
    breaks = c(20, 10*(3:5))
  ) + 
  scale_x_discrete(
    name = "Country"
  ) + 
  theme_minimal() + 
  theme(
    text = element_text(family = "notosanskr", size = 12), 
    plot.margin = margin(14, 7, 3, 1.5)
  )
```

```{r right-bar-plot, fig.cap="2007년 기준 인구 수(백만 명 단위)"}
gapminder %>% 
  filter(continent == "Asia", 
         year == "2007") %>% 
  mutate(pop_million = pop / 1000000) %>% 
  filter(between(pop_million, 20, 60)) %>% 
  
  ggplot(aes(x = country, y = pop_million)) + 
  geom_col(fill = "#FF9436") + 
  coord_cartesian(ylim = c(0, 55), expand = FALSE) + 
  scale_y_continuous(
    name = "Population per million", 
    breaks = c(0, 10*(1:5))
  ) + 
  scale_x_discrete(
    name = "Country"
  ) + 
  theme_minimal() + 
  theme(
    text = element_text(family = "notosanskr", size = 12), 
    plot.margin = margin(14, 7, 3, 1.5)
  )
```

2007년 기준 11 개 국가의 인구 수를 bar plot으로 나타냈다. y축의 시작이 20부터 시작이냐 0부터 시작이냐에 따라 인구 수를 의미하는 bar의 너비가 크게 차이 남을 볼 수 있다. 

시각화는 사실을 간결하지만 분명하게 전달해야 할 필요가 있으므로 위와 같은 왜곡이 발생하지 않도록, 다시 말해 잉크 양 비례 원칙이 지켜질 수 있도록 주의해야 함을 기억하자.  

# ch 18 오버플로팅 : 겹치는 점을 처리하는 방법

x축이나 y축에 명목형 변수를 두고 산점도를 그리면 많은 경우 관측치를 표현하는 점들이 겹치게 되어 오해를 불러올 수 있다. `ggplot2` 패키지나 `base`에서 볼 수 있는 `jitter()`를 이용하면 겹쳐진 점을 살짝 비껴 표현할 수 있어 plot의 왜곡을 방지할 수 있다. 

책에서 소개하고 있는 방법 중 인상깊었던 것은 **2차원 히스토그램**으로 산점과 점들의 분포를 동시에 표현할 수 있는 방법이라는 생각이 들었다. 



```{r nycfilghts13-2d-hist, fig.cap="2차원 히스토그램을 이용한 분 단위 도착 시간 지연과 실제 도착 시간의 비교"}
library(nycflights13)

nycflights13::flights %>%
  filter(!is.na(arr_time)) %>% 
  mutate(arr_time = as.character(arr_time)) %>% 
  mutate(arr_time = 
           ifelse(
             arr_time == "2400",
             "0000",
             arr_time
           )
  ) %>% 
  mutate(arrive_time = 
           case_when(
             str_length(arr_time) == 1 ~ paste0("000", arr_time), 
             str_length(arr_time) == 2 ~ paste0("00", arr_time), 
             str_length(arr_time) == 3 ~ paste0("0", arr_time), 
             str_length(arr_time) == 4 ~ arr_time
           )
  ) %>% 
  
  mutate(arrive_time = parse_time(arrive_time, format = "%H%M")) %>% 

  ggplot(aes(x = arrive_time, y = arr_delay)) +
  geom_abline(slope = 0, intercept = 0, color="grey70") + 
  scale_x_time(
    name = "실제 도착 시각",
    breaks = hm(c("0:00", "6:00", "12:00", "18:00", "24:00")),
    labels = c("0:00", "6:00", "12:00", "18:00", "24:00")
  ) +
  scale_y_continuous(
    name = "도착 지연 시간(분)"
  ) + 
  geom_hex(aes(colour = stat(count)), bins = 100) + 
  scale_fill_continuous_sequential(
    aesthetics = c("colour", "fill"),
    h1 = -83, h2 = 20, c1 = 30, cmax = 40, c2 = 0, l1 = 20, l2 = 94, p1 = 1, p2 = 1.2, 
    rev = TRUE,
    begin = 0.2,
    name = "실제 도착시간의 빈도"
  ) +
  theme_minimal() + 
  theme(
    legend.position = c(0.85, .85), 
    legend.background = element_rect(color="white"),
    text = element_text(family = "notosanskr", size = 12)
    )
```

bins의 모양을 사각형으로 하느냐, 육각형으로 하느냐는 사실 aesthetic의 의미만 있는 줄 알았는데, 책에 다음과 같은 사실이 나온다. 

> This approach, first proposed by Carr et al. ([1987](https://www.jstor.org/stable/2289444)), has the advantage that the points in a hexagon are, on average, closer to the hexagon center than the points in an equal-area square are to the center of the square. Therefore, the colored hexagon represents the data slightly more accurately than the colored rectangle does.

색칠된 육각형이 직사각형에 비해 데이터를 조금 더 정확하게 나타내주는 측면이 있다는 사실이 굉장히 인상깊다. 꼭 기억하자. 










```{r, eval=FALSE, echo=FALSE, include=FALSE}
# 데이터셋 찾아보기 
# https://stackoverflow.com/questions/27709936/get-a-list-of-the-data-sets-in-a-particular-package
library(vcdExtra)
vcdExtra::datasets(c("plyr", "dplyr", "vcdExtra", "ggplot2"))

storms %>% 
  ggplot(aes(x = day, y = wind)) +
  geom_point() + 
   geom_jitter()

?AirCrash # Data on all fatal commercial airplane crashes from 1993–2015. Excludes small planes (less than 6 passengers) and non-commercial (cargo, military, private) aircraft.
# AirCrash로 결정
```

```{r, echo=FALSE, eval=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "19_temp")

for(i in 1:8){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```
