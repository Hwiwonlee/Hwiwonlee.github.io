---
title: "데이터 시각화 교과서(Fundamentals of Data Visualization) 2부"
author: "Hwiwon Lee"
date: "`r format(Sys.Date())`"
categories:
  - visualization
tags:
  - R
  - visualization
output: 
  # https://blog.zarathu.com/posts/2019-01-03-rmarkdown/
    bookdown::html_document2:
      fig_retina : 1
      number_sections: FALSE
      fig_caption: TRUE
      fig_height: 6
      fig_width: 10
      highlight: textmate
      theme: cosmo
      toc: yes
      toc_depth: 4
      toc_float: yes
      css: "post_style.css"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.height = 8, fig.align = "center", cache=T, dpi = 300, dev = "png",
                      comment = "#>")

# https://tibble.tidyverse.org/reference/formatting.html
options(tibble.print_max = 10)
options(tibble.max_extra_cols = 5)
# options(max.print = 300)

library(knitr) # for include_graphics()
library(tidyverse) # as you known, core package
library(googledrive) # Import dataset from the google drive
library(readr) # To read csv file
library(lubridate)
library(operators)
library(magrittr)
library(ggridges) # geom_density_line()을 위한 패키지 로드
library(tinter) # darken()을 위한 패키지 로드
library(pkgsimon) # theme_dviz_hgrid()를 위함
library(showtext)
font_add_google('Noto Sans KR', 'notosanskr')
font_add_google('Noto Sans', 'notosans')
font_add_google('Nanum Gothic', 'nanumgothic')
library(ggforce) # sina plot을 위한 패키지 
# library(dviz.supp) # colorblindr가 4.0.2에서 사용 불가해서 설치가 안됨 
library(foreign)
library(treemapify) # geom_treemap
library(ggrepel) # geom_text_repel
library(ggfortify) # auto_plot for PCA plot 


library(gapminder)
library(colorspace)
library(gridExtra)
```




ch 17 잉크 양 비례의 원칙

**잉크 양 비례의 원칙**(principle of proportinal ink)라는 다소 낯선 개념이 등장한다. 정의는 아래와 같다. 

> The principle of proportional ink: The sizes of shaded areas in a visualization need to be proportional to the data values they represent(색조를 넣은 영역이 수치 값을 나타낼 때, 색조가 들어간 영역의 면적은 해당 값과 정비례해야 한다).

번역본의 주석에 따르면 원래의 정의는 이렇다고 한다. 

> The representation of numbers, as physically measured on the surface of the graphic itself, should be directly proportional to the numerical quantities represented(그래픽 자체의 표면에 숫자를 물리적으로 표현하는 경우, 수치의 크기와 표면적의 넓이는 정비례해야 한다). 


잉크 양 비례의 원칙이라는 말이 와닿지 않아서 그렇지 의미를 보면 그래프를 그리는 사람들 모두가 알고 있는 사실이다. **숫자와 면적이 정비례하게 그릴 것.** 잉크 양 비례의 원칙을 위배한 유명한 예시가 있다.

```{r wrong-pie-chart, echo = FALSE, fig.cap = "JTBC의 유명한 파이차트. 숫자와 해당 카테고리를 의미하는 면적이 일치하지 않으며 심지어 비례하지도 않는다."}
include_graphics("https://www.mediawatch.kr/data/photos/20170312/art_14899947314124_cfb2da.jpg")
```

JTBC 뉴스룸에서 방송된 파이차트([출처](https://www.mediawatch.kr/news/article.html?no=251671))로 대단히 놀라운 수준의 시각화를 보여준다. `잘했다`, `모르겠다`, `잘못했다` 세 범주로 나눠진 설문조사 응답은 차례대로 `64.0%`, `28.7%`, `7.3%`이지만 그래프의 면적은 `잘했다 >= 잘못했다 > 모르겠다`로 보인다. 이 파이차트에서 정확한 것은 설문조사의 응답 범주 뿐이고 나머지는 모두 틀렸다고 봐도 무방하다. 

이렇게 그리지 말라는 것이다. 

책에서는 대부분의 사람들이 한 번 정도는 실수했던 부분에 대해서도 얘기한다. **그래프 축의 시작은 반드시 0이어야 한다.**가 바로 그것이다. 물론, 목적이나 분야에 따라 시작점이 **반드시** 0이 되지 않아도 되는 경우가 있긴 하다. 가령 주가를 다룬 시계열 그래프나 대중 매체에서 사용되는 그래프들이 그렇다. 

하지만 그래프의 축이 0부터 시작하지 않는다면 시각화의 왜곡은 반드시 일어난다. 책에 나온 경우를 표현하기 위해 `gapminder` 데이터셋의 인구 수
를 사용해보았다. 

```{r wrong-bar-plot, fig.cap="2007년 기준 인구 수(백만 명 단위)"}
gapminder %>% 
  filter(continent == "Asia", 
         year == "2007") %>% 
  mutate(pop_million = pop / 1000000) %>% 
  filter(between(pop_million, 20, 60)) %>% 
  
  ggplot(aes(x = country, y = pop_million)) + 
  geom_col(fill = "#FF9436") + 
  coord_cartesian(ylim = c(20, 55), expand = FALSE) + 
  scale_y_continuous(
    name = "Population per million", 
    breaks = c(20, 10*(3:5))
  ) + 
  scale_x_discrete(
    name = "Country"
  ) + 
  theme_minimal() + 
  theme(
    text = element_text(family = "notosanskr", size = 12), 
    plot.margin = margin(14, 7, 3, 1.5)
  )
```

```{r right-bar-plot, fig.cap="2007년 기준 인구 수(백만 명 단위)"}
gapminder %>% 
  filter(continent == "Asia", 
         year == "2007") %>% 
  mutate(pop_million = pop / 1000000) %>% 
  filter(between(pop_million, 20, 60)) %>% 
  
  ggplot(aes(x = country, y = pop_million)) + 
  geom_col(fill = "#FF9436") + 
  coord_cartesian(ylim = c(0, 55), expand = FALSE) + 
  scale_y_continuous(
    name = "Population per million", 
    breaks = c(0, 10*(1:5))
  ) + 
  scale_x_discrete(
    name = "Country"
  ) + 
  theme_minimal() + 
  theme(
    text = element_text(family = "notosanskr", size = 12), 
    plot.margin = margin(14, 7, 3, 1.5)
  )
```

2007년 기준 11 개 국가의 인구 수를 bar plot으로 나타냈다. y축의 시작이 20부터 시작이냐 0부터 시작이냐에 따라 인구 수를 의미하는 bar의 너비가 크게 차이 남을 볼 수 있다. 

시각화는 사실을 간결하지만 분명하게 전달해야 할 필요가 있으므로 위와 같은 왜곡이 발생하지 않도록, 다시 말해 잉크 양 비례 원칙이 지켜질 수 있도록 주의해야 함을 기억하자.  

# ch 18 오버플로팅 : 겹치는 점을 처리하는 방법

x축이나 y축에 명목형 변수를 두고 산점도를 그리면 많은 경우 관측치를 표현하는 점들이 겹치게 되어 오해를 불러올 수 있다. `ggplot2` 패키지나 `base`에서 볼 수 있는 `jitter()`를 이용하면 겹쳐진 점을 살짝 비껴 표현할 수 있어 plot의 왜곡을 방지할 수 있다. 

책에서 소개하고 있는 방법 중 인상깊었던 것은 **2차원 히스토그램**으로 산점과 점들의 분포를 동시에 표현할 수 있는 방법이라는 생각이 들었다. 



```{r nycfilghts13-2d-hist, fig.cap="2차원 히스토그램을 이용한 분 단위 도착 시간 지연과 실제 도착 시간의 비교"}
library(nycflights13)

nycflights13::flights %>%
  filter(!is.na(arr_time)) %>% 
  mutate(arr_time = as.character(arr_time)) %>% 
  mutate(arr_time = 
           ifelse(
             arr_time == "2400",
             "0000",
             arr_time
           )
  ) %>% 
  mutate(arrive_time = 
           case_when(
             str_length(arr_time) == 1 ~ paste0("000", arr_time), 
             str_length(arr_time) == 2 ~ paste0("00", arr_time), 
             str_length(arr_time) == 3 ~ paste0("0", arr_time), 
             str_length(arr_time) == 4 ~ arr_time
           )
  ) %>% 
  
  mutate(arrive_time = parse_time(arrive_time, format = "%H%M")) %>% 

  ggplot(aes(x = arrive_time, y = arr_delay)) +
  geom_abline(slope = 0, intercept = 0, color="grey70") + 
  scale_x_time(
    name = "실제 도착 시각",
    breaks = hm(c("0:00", "6:00", "12:00", "18:00", "24:00")),
    labels = c("0:00", "6:00", "12:00", "18:00", "24:00")
  ) +
  scale_y_continuous(
    name = "도착 지연 시간(분)"
  ) + 
  geom_hex(aes(colour = stat(count)), bins = 100) + 
  scale_fill_continuous_sequential(
    aesthetics = c("colour", "fill"),
    h1 = -83, h2 = 20, c1 = 30, cmax = 40, c2 = 0, l1 = 20, l2 = 94, p1 = 1, p2 = 1.2, 
    rev = TRUE,
    begin = 0.2,
    name = "실제 도착시간의 빈도"
  ) +
  theme_minimal() + 
  theme(
    legend.position = c(0.85, .85), 
    legend.background = element_rect(color="white"),
    text = element_text(family = "notosanskr", size = 12)
    )
```

bins의 모양을 사각형으로 하느냐, 육각형으로 하느냐는 사실 aesthetic의 의미만 있는 줄 알았는데, 책에 다음과 같은 사실이 나온다. 

> This approach, first proposed by Carr et al. ([1987](https://www.jstor.org/stable/2289444)), has the advantage that the points in a hexagon are, on average, closer to the hexagon center than the points in an equal-area square are to the center of the square. Therefore, the colored hexagon represents the data slightly more accurately than the colored rectangle does.

색칠된 육각형이 직사각형에 비해 데이터를 조금 더 정확하게 나타내주는 측면이 있다는 사실이 굉장히 인상깊다. 꼭 기억하자. 


# ch 19 효과적인 색 사용을 위한 조언

여러 색깔을 사용한 그래프는 언뜻 보면 뭔가 있어 보이지만 명확한 의미전달이 힘든 경우가 보통이다. 따라서 지나치게 많은 색깔을 사용하는 것은 지양되어야 하는 것이 마땅하다. 

책에서는 특별히 색맹/색약의 불편함을 가진 사람들을 위한 색 사용을 조언한다. 대부분의 색맹/색약이 녹색, 적색, 청색 인식에 대한 불편을 가져오므로 해당 색깔들은 한 번씩만 사용하길 권장하고 있으며 특별히 정성적 색상(Qualitative color)의 경우, 색맹/색약에 영향을 받지 않는 다음의 색깔을 사용하는 것을 추천했다. 

```{r}
# `colorblindr`이 4.0.2에서 아직 사용할 수 없으므로 새로운 패키지를 사용해서 표현
# https://cran.r-project.org/web/packages/unikn/vignettes/colors.html
library(unikn)
forcolorblind <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")
names(forcolorblind) <- c("주황색", "하늘색", "초록색", "노란색", "파란색", "주홍색", "분홍색", "검은색")

seecol(forcolorblind, grid = FALSE, title = " ")
```
# ch 20 Redundant coding(담백한 디자인의 그래프)

**Redundant coding**는 보통 중복된 코드 디자인을 말하는데...이걸 번역본에서는 **불필요한 기호화**...라고 해놓았다. 원본이랑 번역본을 같이 보는데 종종 **어?**하는 번역이 있었지만 이건 좀...

이번 장에서는 의미 전달을 위한 최적화를 소개한다. 이전 장에서 보았던 색맹/색약의 경우를 대처하기 위한 **색각 이상 시뮬레이션**(Color-vision-deficiency simulation)과 효과적인 범례 표시 및 범례 없는 그래프 등을 보여준다. 

범례 없는 그래프는 무작정 범례를 지우는 것이 아니라 범례에서 전달하는 정보를 그래프에서 전달해 전체적인 통일감과 명확한 표현, 두 마리 토끼를 모두 잡을 수 있는 방법이다. 

그렇긴 한데...사실 실무에서는 그렇게 선호되는 방법은 아닌 것 같다는 게 내 의견이다. 보기엔 좋은데 결정권자의 손을 넘기 힘들다고 해야할까. 내 맘에 드는 그래프보다는 모두가 읽고 이해하기 좋은 그래프를 만드는 것이 더 옳은 일이므로 유연한 사고를 가지는 게 좋은 것 같다. 

```{r}
label_df <- data.frame(
  Species = c("setosa", "virginica", "versicolor"),
  label = c("Iris setosa", "Iris virginica", "Iris versicolor"),
  Sepal.Length = c(5, 7, 6),
  Pepal.Length = c(0.7, 6.8, 3.5),
  hjust = c(0, 0.5, 0),
  vjust = c(0, 0.5, 1))

iris %>% 
  ggplot(aes(x = Sepal.Length,y = Petal.Length,
             color = Species)
  ) + 
  geom_point(
    aes(shape = Species, fill = Species),
    size = 2.5,
    position = position_jitter(
      width = 0.05,
      height = 0.05,
      seed = 1234)
  ) +
  stat_ellipse(size = 0.5) +
  scale_shape_manual(
    values = c(21, 22, 23),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_fill_manual(
    values = c("#D55E0080", "#0072B280", "#009E7380"),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_color_manual(
    values = darken(c("#D55E00", "#0072B2", "#009E73"), 0.3),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_x_continuous(
    limits = c(4, 8.2), expand = c(0, 0),
    breaks = seq(4, 8, 2),
    labels = as.character(seq(4, 8, 2)),
    name = "Sepal Length"
  ) +
  scale_y_continuous(
    limits = c(0, 7.5), expand = c(0, 0),
    breaks = seq(0, 7, 1),
    labels = as.character(seq(0, 7, 1)),
    name = "Petal Length"
  ) +
  guides(fill = "none", color = "none", shape = "none") +
  geom_text(
    data = label_df,
    aes(
      x = Sepal.Length, y = Pepal.Length, label = label, color = Species,
      hjust = hjust, vjust = vjust
    ),
    size = 14/.pt,
    fontface = "italic",
    inherit.aes = FALSE
  ) +
  theme_minimal() -> no_legend_SL_PL

iris %>% 
  ggplot(aes(x = Sepal.Length,y = Petal.Length,
             color = Species)
  ) + 
  geom_point(
    aes(shape = Species, fill = Species),
    size = 2.5,
    position = position_jitter(
      width = 0.05,
      height = 0.05,
      seed = 1234)
  ) +
  stat_ellipse(size = 0.5) +
  scale_shape_manual(
    values = c(21, 22, 23),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_fill_manual(
    values = c("#D55E0080", "#0072B280", "#009E7380"),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_color_manual(
    values = darken(c("#D55E00", "#0072B2", "#009E73"), 0.3),
    breaks = c("setosa", "virginica", "versicolor"),
    name = NULL
  ) +
  scale_x_continuous(
    limits = c(4, 8.2), expand = c(0, 0),
    breaks = seq(4, 8, 2),
    labels = as.character(seq(4, 8, 2)),
    name = "Sepal Length"
  ) +
  scale_y_continuous(
    limits = c(0, 7.5), expand = c(0, 0),
    breaks = seq(0, 7, 1),
    labels = as.character(seq(0, 7, 1)),
    name = "Petal Length"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  ) -> yes_legend_SL_PL


grid.arrange(yes_legend_SL_PL, no_legend_SL_PL, nrow = 2)
```





```{r}
install.packages("remotes")
remotes::install_github("clauswilke/dviz.supp")
```



```{r, eval=FALSE, echo=FALSE, include=FALSE}
# 데이터셋 찾아보기 
# https://stackoverflow.com/questions/27709936/get-a-list-of-the-data-sets-in-a-particular-package
library(vcdExtra)
vcdExtra::datasets(c("plyr", "dplyr", "vcdExtra", "ggplot2"))

storms %>% 
  ggplot(aes(x = day, y = wind)) +
  geom_point() + 
   geom_jitter()

?AirCrash # Data on all fatal commercial airplane crashes from 1993–2015. Excludes small planes (less than 6 passengers) and non-commercial (cargo, military, private) aircraft.
# AirCrash로 결정
```

```{r, echo=FALSE, eval=FALSE}
drive_auth()
data_in_drive <- drive_find(type = "csv", pattern = "19_temp")

for(i in 1:8){ 
  drive_download(file = data_in_drive$name[i], path = data_in_drive$name[i], overwrite = TRUE)
}
```
